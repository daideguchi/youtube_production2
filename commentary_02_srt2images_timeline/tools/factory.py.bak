#!/usr/bin/env python3
"""
Factory CLI: The One-Stop Entry Point for Video Production.
Wraps complex tool chains into simple commands based on user intent.

Usage:
  python factory_cli.py <CHANNEL_ID> <SRT_PATH> [INTENT] [OPTIONS]

Intents:
  new     : (Default) Full pipeline (Images -> Belt -> Draft)
  draft   : Skip image generation, rebuild draft & belt (Resume)
  belt    : Re-generate belt config only (keep images/draft)
  fix     : Force regenerate images and rebuild everything
  check   : Dry-run to validate settings

Examples:
  python factory_cli.py CH01 input/script.srt
  python factory_cli.py CH01 input/script.srt draft
  python factory_cli.py CH01 input/script.srt fix --concurrency 5
"""
import sys
import argparse
import subprocess
import logging
from pathlib import Path
from typing import Optional, List

# Setup path
PROJECT_ROOT = Path(__file__).resolve().parents[1]
sys.path.append(str(PROJECT_ROOT / "src"))

from src.core.config import config
# Ensure we can load domain logic if needed, though mostly we wrapper CLI
# from src.core.domain.channel_schema import ChannelRegistry

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

def run_command(cmd: List[str], cwd: Path = PROJECT_ROOT, check: bool = True):
    """Run a subprocess command with real-time output."""
    cmd_str = " ".join(cmd)
    logger.info(f"üöÄ Executing: {cmd_str}")
    try:
        subprocess.run(cmd, cwd=cwd, check=check)
    except subprocess.CalledProcessError as e:
        logger.error(f"‚ùå Command failed: {cmd_str}")
        sys.exit(e.returncode)

def main():
    parser = argparse.ArgumentParser(description="Factory Commentary CLI Wrapper")
    parser.add_argument("channel", help="Channel ID (e.g., CH01)")
    parser.add_argument("srt", help="Path to input SRT file")
    parser.add_argument("intent", nargs="?", default="new", 
                        choices=["new", "draft", "belt", "fix", "check"],
                        help="Operation mode (default: new)")
    
    # Passthrough options
    parser.add_argument("--concurrency", default="3", help="Image generation concurrency")
    parser.add_argument("--title", help="Explicit video title (overrides LLM generation)")
    parser.add_argument("--labels", help="Explicit belt labels (comma separated)")
    parser.add_argument("--debug", action="store_true", help="Enable dry-run mode")

    args = parser.parse_args()

    # Validate Inputs
    srt_path = Path(args.srt).resolve()
    if not srt_path.exists():
        logger.error(f"‚ùå SRT file not found: {srt_path}")
        sys.exit(1)

    # Construct the base command for auto_capcut_run.py
    # Located in the same directory as this script (tools/)
    tool_path = Path(__file__).resolve().parent / "auto_capcut_run.py"
    
    base_cmd = [
        sys.executable,
        str(tool_path),
        "--channel", args.channel,
        "--srt", str(srt_path),
        "--img-concurrency", args.concurrency,
        "--suppress-warnings"
    ]

    # Apply options based on Intent
    if args.intent == "new":
        logger.info("üé¨ Starting NEW production pipeline...")
        # Default behavior of auto_capcut_run is 'new'
        pass

    elif args.intent == "draft":
        logger.info("‚è© Resuming: Rebuilding DRAFT only (skipping image gen)...")
        base_cmd.append("--resume")
        # Resume mode in auto_capcut_run skips run_pipeline.py unless cues missing

    elif args.intent == "belt":
        logger.info("üéó Regenerating BELT config only...")
        # Belt generation happens in auto_capcut_run. 
        # We use --resume to skip images, but we might want to ensure belt logic runs.
        # auto_capcut_run always runs belt logic unless disabled.
        base_cmd.append("--resume")
        # Logic in auto_capcut_run: "2) belt_config generation" runs after pipeline/resume check.
        # So this works.

    elif args.intent == "fix":
        logger.info("üîß FIX Mode: Forcing regeneration of images...")
        base_cmd.append("--force")

    elif args.intent == "check":
        logger.info("üîç CHECK Mode: Dry-run...")
        base_cmd.append("--dry-run")
        args.debug = True

    # Passthrough explicit overrides
    if args.title:
        base_cmd.extend(["--title", args.title])
    if args.labels:
        base_cmd.extend(["--labels", args.labels])
    if args.debug:
        base_cmd.append("--dry-run")

    # Execute
    print("-" * 60)
    print(f"üè≠ FACTORY JOB: {args.intent.upper()}")
    print(f"üì∫ Channel: {args.channel}")
    print(f"üìú Script : {srt_path.name}")
    print("-" * 60)

    try:
        run_command(base_cmd)
        print("\n‚úÖ Factory job completed successfully!")
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Job cancelled by user.")
        sys.exit(130)

if __name__ == "__main__":
    main()
