#!/usr/bin/env python3
import argparse
import json
import sys
import re
from pathlib import Path

# CapCut API path
sys.path.insert(0, "/Users/dd/capcut_api")

import pyJianYingDraft as draft
from pyJianYingDraft import Draft_folder, Track_type, Video_material, Video_segment, Text_segment, Clip_settings, Timerange, SEC
from pyJianYingDraft import Text_style, Text_background, Text_border
from typing import Optional
import json as _json2
import os
import logging
import traceback

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


# ========================================
# ðŸ›¡ï¸ DEFENSE SYSTEM - Template Validation
# ========================================

def validate_template(draft_root: Path, template_name: str) -> tuple[bool, str]:
    """
    Validate template existence and draft_content.json presence.

    Returns:
        (is_valid, error_message)
    """
    template_path = draft_root / template_name

    if not template_path.exists():
        return False, f"âŒ Template '{template_name}' does not exist at {template_path}"

    if not template_path.is_dir():
        return False, f"âŒ Template '{template_name}' is not a directory"

    draft_content = template_path / "draft_content.json"
    draft_info = template_path / "draft_info.json"

    if not draft_content.exists():
        if draft_info.exists():
            return False, (
                f"âŒ Template '{template_name}' lacks draft_content.json\n"
                f"   (has draft_info.json but pyJianYingDraft 0.2.3 requires draft_content.json)"
            )
        else:
            return False, f"âŒ Template '{template_name}' is not a valid CapCut draft (no JSON files)"

    return True, ""


def list_valid_templates(draft_root: Path, prefix: str = "") -> list[tuple[str, float]]:
    """
    List all valid templates (with draft_content.json).

    Returns:
        List of (template_name, mtime) sorted by modification time (newest first)
    """
    if not draft_root.exists():
        return []

    valid_templates = []
    for entry in draft_root.iterdir():
        if not entry.is_dir():
            continue

        if prefix and not entry.name.startswith(prefix):
            continue

        draft_content = entry / "draft_content.json"
        if draft_content.exists():
            mtime = draft_content.stat().st_mtime
            valid_templates.append((entry.name, mtime))

    valid_templates.sort(key=lambda x: x[1], reverse=True)
    return valid_templates


def find_best_template(draft_root: Path, prefix: str) -> Optional[str]:
    """
    Find the newest valid template matching the prefix.

    Returns:
        Template name or None if not found
    """
    candidates = list_valid_templates(draft_root, prefix)
    if candidates:
        return candidates[0][0]  # Return newest
    return None


def pre_flight_check(args, logger: logging.Logger) -> list[str]:
    """
    Comprehensive pre-flight validation before execution.

    Returns:
        List of error messages (empty if all checks pass)
    """
    errors = []

    # 1. Template validation
    draft_root = Path(args.draft_root)
    template_name = args.template

    valid, msg = validate_template(draft_root, template_name)
    if not valid:
        errors.append(msg)

        # Suggest alternatives
        valid_templates = list_valid_templates(draft_root, args.preferred_template_prefix)
        if valid_templates:
            errors.append("\nðŸ’¡ Available valid templates:")
            for name, mtime in valid_templates[:5]:
                from datetime import datetime
                dt = datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M')
                errors.append(f"   â€¢ {name} (modified: {dt})")

    # 2. Input directory validation
    run_dir = Path(args.run)
    if not run_dir.exists():
        errors.append(f"âŒ Run directory not found: {args.run}")
    else:
        image_cues = run_dir / "image_cues.json"
        if not image_cues.exists():
            errors.append(f"âŒ image_cues.json not found in {args.run}")

        images_dir = run_dir / "images"
        if not images_dir.exists():
            errors.append(f"âŒ images/ directory not found in {args.run}")

    # 3. SRT file validation (if specified)
    if args.srt_file:
        srt_path = Path(args.srt_file)
        if not srt_path.exists():
            errors.append(f"âŒ SRT file not found: {args.srt_file}")

    # 4. Voice file validation (if specified)
    if hasattr(args, 'voice_file') and args.voice_file:
        voice_path = Path(args.voice_file)
        if not voice_path.exists():
            errors.append(f"âŒ Voice file not found: {args.voice_file}")

    # 5. Write permission check
    if not os.access(args.draft_root, os.W_OK):
        errors.append(f"âŒ No write permission to draft root: {args.draft_root}")

    # 6. Draft name conflict check
    new_draft_path = draft_root / args.new
    if new_draft_path.exists():
        logger.warning(f"âš ï¸  Draft '{args.new}' already exists and will be replaced")

    return errors


# ========================================
# Original functions
# ========================================

def load_cues(run_dir: Path):
    data = json.loads((run_dir / "image_cues.json").read_text(encoding="utf-8"))
    fps = int(data["fps"])
    size = data["size"]
    crossfade = float(data.get("crossfade", 0.0))
    cues = data["cues"]
    return fps, size, crossfade, cues


def parse_srt_file(srt_path: Path):
    """Parse SRT file and return list of subtitle entries."""
    if not srt_path.exists():
        return []
    
    content = srt_path.read_text(encoding='utf-8')
    # SRT pattern: index, time, text, blank line
    pattern = r'(\d+)\n(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\n(.*?)(?=\n\n|\n\d+\n|\Z)'
    matches = re.findall(pattern, content, re.DOTALL)
    
    subtitles = []
    for match in matches:
        index, start_time, end_time, text = match
        
        # Convert time to microseconds
        def time_to_us(time_str):
            h, m, s_ms = time_str.split(':')
            s, ms = s_ms.split(',')
            return (int(h) * 3600 + int(m) * 60 + int(s)) * 1000000 + int(ms) * 1000
        
        subtitles.append({
            'index': int(index),
            'start_us': time_to_us(start_time),
            'end_us': time_to_us(end_time),
            'text': text.strip().replace('\n', ' ')
        })
    
    return subtitles


def make_absolute_schedule_us(cues, offset_us=0):
    """Use absolute timing from image_cues.json (start_sec/end_sec) instead of contiguous layout.
    Returns list of (start_us, dur_us) for each cue.

    Args:
        cues: Image cues from image_cues.json
        offset_us: Time offset in microseconds to add to all timestamps (for opening)
    """
    SEC_US = 1_000_000
    starts = []
    for c in cues:
        start_us = int(round(float(c.get("start_sec", 0.0)) * SEC_US)) + offset_us
        end_us = int(round(float(c.get("end_sec", 0.0)) * SEC_US)) + offset_us
        if end_us <= start_us:
            # Fallback to duration_sec if provided; else minimum 1 frame at 30fps
            dur_us = int(round(float(c.get("duration_sec", 1.0)) * SEC_US))
        else:
            dur_us = end_us - start_us
        starts.append((start_us, max(SEC // 60, dur_us)))  # minimum ~16ms to avoid zero-length
    return starts


def ensure_video_track(script: draft.Script_file, name: str, absolute_index: Optional[int] = None):
    """Ensure a top-most video track exists with predictable name.
    If the track exists, bump its absolute_index to an extremely high number
    to guarantee it renders above all template overlays.
    """
    HIGH = 999999 if absolute_index is None else absolute_index
    try:
        script.add_track(Track_type.video, name, absolute_index=HIGH)
    except Exception:
        # If it already exists, try to bump its index
        try:
            tr = script.tracks[name]
            # Some pyJianYingDraft versions expose .absolute_index, others .render_index
            if hasattr(tr, 'absolute_index'):
                tr.absolute_index = HIGH
            elif hasattr(tr, 'render_index'):
                tr.render_index = HIGH
        except Exception:
            pass


def _load_draft_track_indices(draft_dir: Path) -> list[int]:
    """Parse draft_info.json to collect existing tracks' absolute indices.
    Return a list of integer indices (may be empty on failure).
    """
    indices: list[int] = []
    try:
        info_path = draft_dir / 'draft_info.json'
        data = _json2.loads(info_path.read_text(encoding='utf-8'))
        tracks = data.get('tracks') or data.get('script', {}).get('tracks')
        it = []
        if isinstance(tracks, dict):
            it = tracks.values()
        elif isinstance(tracks, list):
            it = tracks
        for tr in it:
            ai = tr.get('absolute_index') or tr.get('render_index') or tr.get('z_index')
            if isinstance(ai, int):
                indices.append(ai)
    except Exception:
        pass
    return indices


def _compute_abs_index_for_rank(draft_dir: Path, rank_from_top: int = 3, default_high: int = 1_000_000) -> int:
    """Compute an absolute_index so that the new track appears at the given rank from top.
    We try to place it below the top (rank-1) tracks but above the next, using the
    existing absolute_index distribution. Fallback to default_high-(rank-1).
    """
    try:
        indices = sorted(set(_load_draft_track_indices(draft_dir)), reverse=True)
        if not indices:
            return default_high - (rank_from_top - 1)
        # If there are fewer tracks than rank, place relative to current max
        if len(indices) < rank_from_top:
            return indices[0] - (rank_from_top - 1)
        # Desired window: strictly between indices[rank-2] (second for rank=3) and indices[rank-1]
        upper = indices[rank_from_top - 2]  # rank-1 from top
        lower = indices[rank_from_top - 1]  # rank from top currently
        # Try between upper and lower
        if upper - lower >= 2:
            return lower + 1
        # Otherwise, nudge below upper if possible
        cand = upper - 1
        if cand > lower:
            return cand
        # As a last resort, place at lower (may tie) or default fallback
        return lower
    except Exception:
        return default_high - (rank_from_top - 1)


def _read_tracks_meta(draft_dir: Path):
    try:
        info_path = draft_dir / 'draft_info.json'
        data = _json2.loads(info_path.read_text(encoding='utf-8'))
        tracks = data.get('tracks') or data.get('script', {}).get('tracks')
        if isinstance(tracks, dict):
            items = []
            for k, v in tracks.items():
                it = dict(v)
                it['name'] = k
                items.append(it)
            return items
        elif isinstance(tracks, list):
            return tracks
    except Exception:
        return []
    return []


def _compute_audio_voice_index_below_bgm(draft_dir: Path, fallback: int = 10) -> int:
    tracks = _read_tracks_meta(draft_dir)
    audio_indices = []
    for tr in tracks:
        if tr.get('type') == 'audio':
            ai = tr.get('absolute_index') or tr.get('render_index') or tr.get('z_index')
            if isinstance(ai, int):
                audio_indices.append(ai)
    if not audio_indices:
        return fallback
    bgm_idx = max(audio_indices)
    return max(1, bgm_idx - 1)


def fix_image_track_render_timerange(draft_dir: Path) -> bool:
    """
    Fix render_timerange for image/video segments.

    pyJianYingDraft may not set render_timerange correctly for image materials,
    causing CapCut to not display images. This function sets render_timerange
    to match the material's actual duration.

    Returns:
        True if fix successful, False otherwise
    """
    try:
        draft_content_path = draft_dir / "draft_content.json"
        if not draft_content_path.exists():
            logger.warning("Cannot fix render_timerange: draft_content.json not found")
            return False

        with open(draft_content_path, 'r', encoding='utf-8') as f:
            data = _json2.load(f)

        # Backup
        backup_path = draft_dir / "draft_content.json.bak_render_fix"
        with open(backup_path, 'w', encoding='utf-8') as f:
            _json2.dump(data, f, ensure_ascii=False, indent=2)

        # Get materials dict for lookup
        materials = data.get('materials', {})
        videos = materials.get('videos', [])

        # Create material_id -> material mapping
        material_dict = {vid['id']: vid for vid in videos}

        # Fix all video tracks
        tracks = data.get('tracks', [])
        fixed_count = 0

        for track in tracks:
            if track.get('type') != 'video':
                continue

            for seg in track.get('segments', []):
                mat_id = seg.get('material_id', '')
                if mat_id in material_dict:
                    material = material_dict[mat_id]
                    mat_duration = material.get('duration', 0)

                    # Set render_timerange properly
                    # start=0 means use from beginning of material
                    # duration=mat_duration means use entire material
                    seg['render_timerange'] = {
                        'start': 0,
                        'duration': mat_duration
                    }
                    fixed_count += 1

        logger.info(f"   Fixed render_timerange for {fixed_count} video segments")

        # Save
        with open(draft_content_path, 'w', encoding='utf-8') as f:
            _json2.dump(data, f, ensure_ascii=False, indent=2)

        return True

    except Exception as e:
        logger.error(f"Failed to fix render_timerange: {e}")
        return False


def sync_draft_info_with_content(draft_dir: Path) -> bool:
    """
    Sync draft_info.json with draft_content.json.

    pyJianYingDraft 0.2.3 only updates draft_content.json, causing CapCut to ignore changes.
    This function syncs tracks and materials from draft_content to draft_info.

    Returns:
        True if sync successful, False otherwise
    """
    try:
        draft_content_path = draft_dir / "draft_content.json"
        draft_info_path = draft_dir / "draft_info.json"

        if not draft_content_path.exists() or not draft_info_path.exists():
            logger.warning("Cannot sync: draft_content.json or draft_info.json not found")
            return False

        # Load both files
        content_data = _json2.loads(draft_content_path.read_text(encoding='utf-8'))
        info_data = _json2.loads(draft_info_path.read_text(encoding='utf-8'))

        # Sync tracks
        content_tracks = content_data.get('tracks', [])
        info_tracks = info_data.get('tracks', [])

        synced_tracks = []
        for idx, content_track in enumerate(content_tracks):
            # draft_info.json segments should only have {'id': '...'}
            info_segments = [{'id': seg.get('id', '')} for seg in content_track.get('segments', [])]

            if idx < len(info_tracks):
                # Update existing track
                info_track = dict(info_tracks[idx])
                info_track.update({
                    'type': content_track.get('type'),
                    'name': content_track.get('name', ''),
                    'attribute': content_track.get('attribute', 0),
                    'flag': content_track.get('flag', 0),
                    'segments': info_segments
                })
                synced_tracks.append(info_track)
            else:
                # Add new track
                new_track = {
                    'id': content_track.get('id', f'track_{idx}'),
                    'type': content_track.get('type'),
                    'name': content_track.get('name', ''),
                    'attribute': content_track.get('attribute', 0),
                    'flag': content_track.get('flag', 0),
                    'segments': info_segments
                }
                synced_tracks.append(new_track)

        info_data['tracks'] = synced_tracks

        # Sync materials (critical for CapCut to recognize new images/videos)
        content_materials = content_data.get('materials', {})
        info_data['materials'] = content_materials

        # Sync duration
        content_duration = content_data.get('duration', 0)
        info_data['duration'] = content_duration

        # Save updated draft_info.json
        draft_info_path.write_text(_json2.dumps(info_data, ensure_ascii=False, indent=2), encoding='utf-8')

        logger.info(f"âœ… Synced draft_info.json: {len(synced_tracks)} tracks, {len(content_materials.get('videos', []))} video materials")

        return True

    except Exception as e:
        logger.error(f"Failed to sync draft_info.json: {e}")
        logger.debug(traceback.format_exc())
        return False


def move_and_update_belt_tracks_jinsei(belt_data, opening_offset, draft_dir, logger, title=None):
    """
    äººç”Ÿã®é“æ¨™å°‚ç”¨: æ—¢å­˜å¸¯ãƒˆãƒ©ãƒƒã‚¯ã‚’ä¸Šæ›¸ããƒ»æœ€ä¸Šä½ã«ç§»å‹•

    ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å¸¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ï¼š
    1. material ã® text ã®ã¿æ›´æ–°ï¼ˆstyles ã¯ä¸€åˆ‡è§¦ã‚‰ãªã„ï¼‰
    2. timerange ã®ã¿èª¿æ•´
    3. ä½ç½®ã‚’æ–‡å­—æ•°ãƒ™ãƒ¼ã‚¹ã§èª¿æ•´ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    4. ãƒˆãƒ©ãƒƒã‚¯ã‚’æœ€ä¸Šä½ã«ç§»å‹•
    """
    try:
        # å¸¯ä½ç½®è¨ˆç®—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import sys
        from pathlib import Path as _Path
        sys.path.insert(0, str(_Path(__file__).parent))
        from belt_position_calculator import calculate_belt_x_position, get_belt_style_settings

        draft_content_path = draft_dir / 'draft_content.json'
        import json as _json_belt
        content_data = _json_belt.loads(draft_content_path.read_text(encoding='utf-8'))

        SEC = 1_000_000
        opening_offset_us = int(opening_offset * SEC)
        total_duration_us = int(belt_data.get('total_duration', 903.42) * SEC)

        # ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚’å–å¾—
        style_settings = get_belt_style_settings()

        # belt_dataã®æ§‹é€ ã‚’å‡¦ç†
        # æ–°å½¢å¼ï¼ˆbelt_config.jsonï¼‰
        if 'belts' in belt_data:
            belts = belt_data['belts']
            # beltsé…åˆ—ã‚’belt_upperã«å¤‰æ›
            belt_upper = []
            for belt in belts:
                belt_upper.append({
                    'text': belt['text'],
                    'start_sec': belt['start'],
                    'duration_sec': belt['end'] - belt['start']
                })
            # ãƒ¡ã‚¤ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ç”¨ã®ãƒ‡ãƒ¼ã‚¿
            belt_lower = {'text': title if title else 'äººç”Ÿã®é“æ¨™'}
        else:
            # æ—§å½¢å¼ï¼ˆäº’æ›æ€§ç¶­æŒï¼‰
            belt_lower = belt_data.get('belt_lower', {})
            belt_upper = belt_data.get('belt_upper', [])

        tracks = content_data.get('tracks', [])
        texts = content_data.get('materials', {}).get('texts', [])

        subtitle_belt_track_idx = None
        main_belt_track_idx = None

        # æ—¢å­˜ã®å¸¯ãƒˆãƒ©ãƒƒã‚¯ã‚’æŽ¢ã™
        for idx, track in enumerate(tracks):
            track_type = track.get('type', '')
            seg_count = len(track.get('segments', []))

            if track_type == 'text' and seg_count == 4:
                subtitle_belt_track_idx = idx
                logger.info(f"  âœ… ã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«å¸¯ç™ºè¦‹: Track {idx}")
            elif track_type == 'text' and seg_count == 1:
                main_belt_track_idx = idx
                logger.info(f"  âœ… ãƒ¡ã‚¤ãƒ³å¸¯ç™ºè¦‹: Track {idx}")

        if subtitle_belt_track_idx is None or main_belt_track_idx is None:
            logger.error("  âŒ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å¸¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return

        # ã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«å¸¯ã‚’æ›´æ–°
        subtitle_track = tracks[subtitle_belt_track_idx]
        for idx, (segment, chapter) in enumerate(zip(subtitle_track['segments'], belt_upper)):
            # æ™‚é–“ç¯„å›²ã‚’æ›´æ–°
            start_us = int(chapter['start_sec'] * SEC) + opening_offset_us
            duration_us = int(chapter['duration_sec'] * SEC)
            segment['target_timerange'] = {
                'start': start_us,
                'duration': duration_us
            }

            # ä½ç½®ã‚’æ–‡å­—æ•°ãƒ™ãƒ¼ã‚¹ã§è¨ˆç®—ã—ã¦è¨­å®š
            text = chapter['text']
            x = calculate_belt_x_position(text)

            # clipã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒãªã‘ã‚Œã°ä½œæˆ
            if 'clip' not in segment:
                segment['clip'] = {}
            if 'transform' not in segment['clip']:
                segment['clip']['transform'] = {}
            if 'scale' not in segment['clip']:
                segment['clip']['scale'] = {}

            # ä½ç½®ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®š
            segment['clip']['transform']['x'] = x
            segment['clip']['transform']['y'] = style_settings['clip_y']
            segment['clip']['scale']['x'] = style_settings['scale_x']
            segment['clip']['scale']['y'] = style_settings['scale_y']

            # material ã® text ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
            material_id = segment.get('material_id')
            if material_id:
                for mat in texts:
                    if mat.get('id') == material_id:
                        import json as _json_text
                        content_obj = _json_text.loads(mat['content'])
                        content_obj['text'] = chapter['text']
                        mat['content'] = _json_text.dumps(content_obj, ensure_ascii=False)

                        # ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚’é©ç”¨
                        mat['alignment'] = style_settings['alignment']
                        mat['fixed_width'] = style_settings['fixed_width']
                        mat['background_width'] = style_settings['background_width']
                        mat['background_height'] = style_settings['background_height']
                        mat['background_color'] = style_settings['background_color']
                        mat['background_round_radius'] = style_settings['background_round_radius']
                        mat['background_alpha'] = style_settings['background_alpha']

                        logger.info(f"  ðŸ“ ç« {idx+1}: {chapter['text']} (x={x:.4f})")
                        break

        # ãƒ¡ã‚¤ãƒ³å¸¯ã‚’æ›´æ–°
        main_track = tracks[main_belt_track_idx]
        segment = main_track['segments'][0]
        segment['target_timerange'] = {
            'start': opening_offset_us,
            'duration': total_duration_us - opening_offset_us
        }

        material_id = segment.get('material_id')
        if material_id:
            for mat in texts:
                if mat.get('id') == material_id:
                    import json as _json_text
                    content_obj = _json_text.loads(mat['content'])
                    content_obj['text'] = belt_lower['text']
                    mat['content'] = _json_text.dumps(content_obj, ensure_ascii=False)
                    logger.info(f"  ðŸ“ ãƒ¡ã‚¤ãƒ³å¸¯: {belt_lower['text'][:30]}...")
                    break

        # ãƒˆãƒ©ãƒƒã‚¯ã‚’æœ€ä¸Šä½ã«ç§»å‹•
        subtitle_track_obj = tracks.pop(subtitle_belt_track_idx)
        # main_belt_track_idx ãŒ subtitle ã‚ˆã‚Šå¾Œã‚ã®å ´åˆã€pop ã§1ã¤ãšã‚Œã‚‹
        if main_belt_track_idx > subtitle_belt_track_idx:
            main_belt_track_idx -= 1
        main_track_obj = tracks.pop(main_belt_track_idx)

        tracks.append(subtitle_track_obj)
        tracks.append(main_track_obj)
        logger.info("  âœ… å¸¯ãƒˆãƒ©ãƒƒã‚¯ã‚’æœ€ä¸Šä½ã«ç§»å‹•")

        # ä¿å­˜
        content_data['tracks'] = tracks
        draft_content_path.write_text(_json_belt.dumps(content_data, ensure_ascii=False, indent=2))
        logger.info("  âœ… å¸¯ãƒˆãƒ©ãƒƒã‚¯æ›´æ–°å®Œäº†")

    except Exception as e:
        logger.error(f"å¸¯ãƒˆãƒ©ãƒƒã‚¯æ›´æ–°å¤±æ•—: {e}")
        import traceback
        logger.debug(traceback.format_exc())


def adjust_effect_duration(script, total_duration_sec, draft_dir, logger):
    """
    ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒˆãƒ©ãƒƒã‚¯ã®ã‚¨ãƒ³ãƒ‰ä½ç½®ã‚’èª¿æ•´

    ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒˆãƒ©ãƒƒã‚¯ã®æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®durationã‚’å‹•ç”»ã®é•·ã•ã«åˆã‚ã›ã‚‹
    """
    try:
        draft_content_path = draft_dir / 'draft_content.json'
        import json as _json_effect
        content_data = _json_effect.loads(draft_content_path.read_text(encoding='utf-8'))

        SEC = 1_000_000
        total_duration_us = int(total_duration_sec * SEC)

        tracks = content_data.get('tracks', [])
        effect_track_idx = None

        # ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒˆãƒ©ãƒƒã‚¯ã‚’æŽ¢ã™
        for idx, track in enumerate(tracks):
            track_type = track.get('type', '')
            if track_type == 'effect':
                effect_track_idx = idx
                logger.info(f"  âœ… ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒˆãƒ©ãƒƒã‚¯ç™ºè¦‹: Track {idx}")
                break

        # ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®çµ‚äº†ä½ç½®ã‚’èª¿æ•´
        if effect_track_idx is not None:
            track = tracks[effect_track_idx]
            segments = track.get('segments', [])

            if segments:
                # æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®durationã‚’èª¿æ•´
                segment = segments[0]
                old_duration = segment.get('target_timerange', {}).get('duration', 0)
                segment['target_timerange']['duration'] = total_duration_us

                old_sec = old_duration / SEC
                logger.info(f"  â±ï¸  ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµ‚äº†ä½ç½®èª¿æ•´: {old_sec:.1f}s â†’ {total_duration_sec:.1f}s")

                # material_timerangeã‚‚èª¿æ•´ï¼ˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆç´ æã®é•·ã•ï¼‰
                if 'material_timerange' in segment:
                    segment['material_timerange']['duration'] = total_duration_us

        # æ›´æ–°ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¿å­˜
        draft_content_path.write_text(_json_effect.dumps(content_data, ensure_ascii=False, indent=2))
        logger.info("  âœ… ã‚¨ãƒ•ã‚§ã‚¯ãƒˆèª¿æ•´å®Œäº†")

    except Exception as e:
        logger.error(f"ã‚¨ãƒ•ã‚§ã‚¯ãƒˆèª¿æ•´å¤±æ•—: {e}")
        import traceback
        logger.debug(traceback.format_exc())


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--run", required=True, help="srt2images output run dir (contains image_cues.json and images/)")
    ap.add_argument("--draft-root", default=str(Path.home() / "Movies/CapCut/User Data/Projects/com.lveditor.draft"))
    # Senior Romance default template (common minimal package)
    ap.add_argument("--template", required=False, default="ã‚·ãƒ‹ã‚¢æ‹æ„›ãƒ†ãƒ³ãƒ—ãƒ¬", help="Existing CapCut draft folder name to duplicate (Senior Romance default)")
    ap.add_argument("--preferred-template-prefix", default="ã‚·ãƒ‹ã‚¢æ‹æ„›ãƒ†ãƒ³ãƒ—ãƒ¬", help="When exact template name not found, pick the newest starting with this prefix")
    ap.add_argument("--new", default="5-ã‚³ãƒ”ãƒ¼-ç”»åƒç‰ˆ", help="New draft folder name")
    ap.add_argument("--transition", default="Dissolve")
    ap.add_argument("--crossfade", type=float, default=0.5)
    # Position/scale defaults (corrected for exact user coordinates: X=-313, Y=217, Scale=59%)
    ap.add_argument("--tx", type=float, default=-0.3125, help="transform_x (half-canvas units)")
    # NOTE: In CapCut, positive transform_y moves UP. UI Y=+pixels (down) => negative transform_y
    ap.add_argument("--ty", type=float, default=0.20555555555, help="transform_y (half-canvas units)")
    ap.add_argument("--scale", type=float, default=0.59)
    ap.add_argument("--title", help="Left-top title text to set")
    ap.add_argument("--title-duration", type=float, default=30.0, help="Title display duration (seconds)")
    ap.add_argument("--srt-file", help="SRT file path for subtitle insertion")
    ap.add_argument("--inject-into-main", action="store_true", help="Insert into the first existing video track instead of creating a new one")
    ap.add_argument("--rank-from-top", type=int, default=4, help="Desired layer rank from top (1=topmost). Images will be placed on this layer rank.")
    ap.add_argument("--voice-file", help="Voice audio file (WAV/MP3) to insert below BGM (optional)")
    ap.add_argument("--opening-offset", type=float, default=3.0, help="Opening duration offset (seconds) - all elements start after this (default: 3.0)")
    ap.add_argument("--belt-config", help="Belt layer config JSON file (belt_config.json)")
    ap.add_argument("--validate-only", action="store_true", help="Validate inputs without creating draft (dry-run mode)")
    args = ap.parse_args()

    # ========================================
    # ðŸ›¡ï¸ PRE-FLIGHT CHECK - Fail Fast
    # ========================================
    logger.info("ðŸ” Running pre-flight checks...")
    validation_errors = pre_flight_check(args, logger)

    if validation_errors:
        logger.error("\nâŒ Pre-flight check FAILED:")
        for error in validation_errors:
            logger.error(error)
        sys.exit(1)

    logger.info("âœ… Pre-flight checks passed")

    if args.validate_only:
        logger.info("âœ… Validation successful (--validate-only mode, exiting)")
        sys.exit(0)

    run_dir = Path(args.run).resolve()
    images_dir = run_dir / "images"
    fps, size, crossfade_from_run, cues = load_cues(run_dir)
    crossfade = args.crossfade if args.crossfade is not None else crossfade_from_run

    # Calculate opening offset in microseconds
    opening_offset_us = int(args.opening_offset * 1_000_000)

    # Build absolute schedule from cues' start/end seconds (do not force contiguous)
    schedule = make_absolute_schedule_us(cues, offset_us=opening_offset_us)
    width, height = size["width"], size["height"]

    # Duplicate draft (template already validated by pre_flight_check)
    df = Draft_folder(args.draft_root)
    template_name = args.template
    logger.info(f"ðŸ“‹ Using template: {template_name}")

    try:
        df.duplicate_as_template(template_name, args.new, allow_replace=True)
        logger.info(f"âœ… Duplicated template to: {args.new}")
    except Exception as e:
        logger.error(f"âŒ Failed to duplicate template '{template_name}': {e}")
        logger.debug(traceback.format_exc())
        raise
    script = df.load_template(args.new)
    draft_dir = Path(args.draft_root) / args.new
    assets_dir = draft_dir / 'assets' / 'image'
    assets_dir.mkdir(parents=True, exist_ok=True)
    # Decide target track
    if args.inject_into_main:
        # Try to find an existing primary video track
        target_track = None
        try:
            for name, tr in getattr(script, 'tracks', {}).items():
                if hasattr(tr, 'type') and tr.type == Track_type.video:
                    target_track = name
                    break
        except Exception:
            target_track = None
        if not target_track:
            target_track = "main_video"
            desired_index = _compute_abs_index_for_rank(draft_dir, args.rank_from_top)
            ensure_video_track(script, name=target_track, absolute_index=desired_index)
        track_name = target_track
        try:
            script.tracks[track_name].segments = []
        except Exception:
            pass
    else:
        base = f"srt2images_{run_dir.name}"
        track_name = base
        # Ensure unique track name
        idx = 1
        while getattr(script, 'tracks', {}).get(track_name):
            idx += 1
            track_name = f"{base}_{idx}"
        desired_index = _compute_abs_index_for_rank(draft_dir, args.rank_from_top)
        ensure_video_track(script, name=track_name, absolute_index=desired_index)
        # Clear our track if it already has segments
        try:
            script.tracks[track_name].segments = []
        except Exception:
            pass

    # Insert images
    prev_end_us = None
    for i, cue in enumerate(cues):
        img = images_dir / f"{i+1:04d}.png"
        dest = assets_dir / img.name
        try:
            import shutil
            shutil.copy2(img, dest)
        except Exception:
            pass
        # Absolute timing from cues
        start_us, dur_us = schedule[i]
        # Material: reference draft-local asset path to avoid relinking
        # Updated for pyJianYingDraft 0.2.x API (removed material_type and replace_path)
        mat = Video_material(path=str(dest), material_name=img.name)
        # Register material into the draft to ensure materials.images contains it
        try:
            script.add_material(mat)
        except Exception as e:
            print(f"Warning: Failed to add_material for {img.name}: {e}")

        seg = Video_segment(
            mat,
            target_timerange=Timerange(start_us, dur_us),
            source_timerange=Timerange(0, dur_us),
            clip_settings=Clip_settings(transform_x=args.tx, transform_y=args.ty, scale_x=args.scale, scale_y=args.scale),
        )
        # Apply transition to current segment (CapCut applies transition at boundary; clips should not overlap)
        # Disabled due to pyJianYingDraft 0.2.x API changes
        # if args.transition and crossfade > 0 and i > 0 and prev_end_us is not None and abs(start_us - prev_end_us) < int(0.02 * SEC):
        #     try:
        #         ttype = getattr(draft.CapCut_Transition_type, args.transition)
        #     except Exception:
        #         ttype = getattr(draft.Transition_type, args.transition)
        #     seg.add_transition(ttype, duration=int(crossfade * 1e6))

        script.add_segment(seg, track_name=track_name)
        prev_end_us = start_us + dur_us

    # Add title text if specified
    if args.title:
        try:
            # Search for existing text tracks
            text_tracks = []
            for track_name_check, track in script.tracks.items():
                if hasattr(track, 'type') and track.type == Track_type.text:
                    text_tracks.append((track_name_check, track))
            
            if not text_tracks:
                # Create new text track
                title_track_name = "title_text"
                script.add_track(Track_type.text, title_track_name, absolute_index=1000000)
                
                # Create text segment  
                title_duration_us = int(args.title_duration * SEC)
                try:
                    # Try new API (text + timerange as separate args)
                    text_seg = Text_segment(
                        args.title,
                        target_timerange=Timerange(0, title_duration_us)
                    )
                except TypeError:
                    # Try newer API (timerange as first positional arg)
                    try:
                        text_seg = Text_segment(
                            target_timerange=Timerange(0, title_duration_us)
                        )
                        text_seg.text = args.title
                    except Exception:
                        # Fallback: create minimal and set attributes
                        text_seg = Text_segment(Timerange(0, title_duration_us))
                        text_seg.text = args.title
                script.add_segment(text_seg, track_name=title_track_name)
                print(f"Added new title: '{args.title}'")
            else:
                # Update existing text track
                for track_name_check, track in text_tracks:
                    if hasattr(track, 'segments') and track.segments:
                        first_segment = track.segments[0]
                        if hasattr(first_segment, 'text'):
                            print(f"Updated title from '{first_segment.text}' to '{args.title}'")
                            first_segment.text = args.title
                            break
        except Exception as e:
            print(f"Warning: Failed to set title '{args.title}': {e}")

    # Add SRT subtitles if specified - with äººç”Ÿã®é“æ¨™ style design
    if args.srt_file:
        try:
            srt_path = Path(args.srt_file)
            if srt_path.exists():
                # Copy SRT file to draft directory for reference
                draft_path = Path(args.draft_root) / args.new
                srt_dest = draft_path / f"{args.new}.srt"
                import shutil as _sh
                try:
                    _sh.copy2(srt_path, srt_dest)
                    print(f"Copied SRT file to {srt_dest} for CapCut to use directly")
                except Exception:
                    pass

                # Insert subtitles on a dedicated top text layer (above images)
                subs = parse_srt_file(srt_path)
                if subs:
                    sub_track_name = "subtitles_text"
                    try:
                        # Ensure a very high absolute index so text stays on top
                        script.add_track(Track_type.text, sub_track_name, absolute_index=2_000_000)
                    except Exception:
                        pass
                    # Clear existing
                    try:
                        script.tracks[sub_track_name].segments = []
                    except Exception:
                        pass
                    # Create äººç”Ÿã®é“æ¨™ style settings (universal for all templates)
                    subtitle_style = Text_style(
                        size=5.0,
                        color=(1.0, 1.0, 1.0),  # White
                        alpha=1.0,
                        align=1,  # Center alignment
                        line_spacing=2  # 0.02 in percentage = 2 in line_spacing units
                    )

                    subtitle_background = Text_background(
                        color="#000000",  # Black
                        alpha=1.0,
                        round_radius=0.4,  # 40% rounded corners
                        style=1,
                        height=0.28,
                        width=0.28,
                        horizontal_offset=0.0,
                        vertical_offset=0.0
                    )

                    subtitle_border = Text_border(
                        width=0.08,
                        alpha=1.0,
                        color=(0.0, 0.0, 0.0)  # Black border (RGB tuple)
                    )

                    subtitle_clip = Clip_settings(
                        transform_x=0.0,  # Center
                        transform_y=-0.8,  # Upper area
                        scale_x=1.0,
                        scale_y=1.0
                    )

                    added = 0
                    for ent in subs:
                        start_us = int(ent['start_us']) + opening_offset_us
                        dur_us = max(SEC // 60, int(ent['end_us'] - ent['start_us']))
                        text_val = ent.get('text', '')
                        try:
                            # Create text segment with full äººç”Ÿã®é“æ¨™ design
                            text_seg = Text_segment(
                                text_val,
                                Timerange(start_us, dur_us),
                                style=subtitle_style,
                                background=subtitle_background,
                                border=subtitle_border,
                                clip_settings=subtitle_clip
                            )
                        except Exception as e:
                            # Fallback: minimal style
                            try:
                                text_seg = Text_segment(text_val, Timerange(start_us, dur_us))
                                print(f"Warning: Could not apply full style to segment: {e}")
                            except Exception:
                                continue
                        try:
                            script.add_segment(text_seg, track_name=sub_track_name)
                            added += 1
                        except Exception:
                            continue
                    print(f"Inserted {added} subtitle segments on track '{sub_track_name}' with äººç”Ÿã®é“æ¨™ design")
                else:
                    print("Warning: Parsed 0 subtitle entries from SRT")
            else:
                print(f"Warning: SRT file not found: {srt_path}")
        except Exception as e:
            print(f"Warning: Failed to insert SRT subtitles: {e}")

    # Insert voice audio if provided
    if getattr(args, 'voice_file', None):
        try:
            vpath = Path(args.voice_file)
            if vpath.exists():
                # Copy to materials/audio
                audio_dir = draft_dir / 'materials' / 'audio'
                audio_dir.mkdir(parents=True, exist_ok=True)
                voice_dest = audio_dir / vpath.name
                try:
                    import shutil as _sh
                    _sh.copy2(vpath, voice_dest)
                except Exception:
                    pass
                # Ensure audio track below BGM
                voice_track = 'voiceover'
                voice_index = _compute_audio_voice_index_below_bgm(draft_dir, fallback=5)
                try:
                    script.add_track(Track_type.audio, voice_track, absolute_index=voice_index)
                except Exception:
                    pass
                # Determine total timeline duration from cues/schedule
                total_us = 0
                try:
                    for s, d in schedule:
                        total_us = max(total_us, s + d)
                except Exception:
                    total_us = int(60 * SEC)

                # Voice audio should match the actual content duration (without opening offset)
                # Since schedule already includes opening_offset_us, subtract it for voice duration
                voice_duration_us = total_us - opening_offset_us

                try:
                    from pyJianYingDraft import Audio_material, Audio_segment
                    # Updated for pyJianYingDraft 0.2.x API (removed replace_path)
                    amat = Audio_material(path=str(voice_dest), material_name=vpath.name)
                    try:
                        script.add_material(amat)
                    except Exception:
                        pass
                    aseg = Audio_segment(amat, target_timerange=Timerange(0, voice_duration_us))
                    script.add_segment(aseg, track_name=voice_track)
                    print(f"Inserted voice audio '{vpath.name}' on track '{voice_track}'")
                except Exception as e:
                    print(f"Warning: Failed to insert voice audio: {e}")
            else:
                print(f"Warning: Voice file not found: {vpath}")
        except Exception as e:
            print(f"Warning: Voice insert error: {e}")

    # Save back to JSON (in-place)
    script.save()
    print(f"Inserted {len(cues)} images into draft: {args.new}\nLocation: {args.draft_root}/{args.new}")

    # ========================================
    # ðŸ”§ CRITICAL FIX: Set render_timerange for image segments
    # ========================================
    # pyJianYingDraft doesn't set render_timerange correctly, causing images not to display
    logger.info("ðŸ–¼ï¸  Fixing render_timerange for image segments...")
    if fix_image_track_render_timerange(draft_dir):
        logger.info("âœ… Image render_timerange fixed")
    else:
        logger.warning("âš ï¸  render_timerange fix failed - images may not display")

    # ========================================
    # ðŸ”§ CRITICAL: Sync draft_info.json with draft_content.json
    # ========================================
    # pyJianYingDraft 0.2.3 only updates draft_content.json
    # CapCut requires BOTH files to be in sync to recognize tracks/materials
    logger.info("ðŸ”„ Syncing draft_info.json with draft_content.json...")
    if sync_draft_info_with_content(draft_dir):
        logger.info("âœ… Draft files synchronized - CapCut will now recognize all changes")
    else:
        logger.warning("âš ï¸  Draft sync failed - manual sync may be required")
        logger.warning(f"   Run: python3 tools/sync_draft_files_complete.py '{draft_dir}'")

    # ========================================
    # ðŸŽ¯ äººç”Ÿã®é“æ¨™å°‚ç”¨: ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ï¼ˆscript.save()å¾Œã«å®Ÿè¡Œï¼‰
    # ========================================
    if args.belt_config:
        try:
            import json as _json
            belt_config_path = Path(args.belt_config)
            if belt_config_path.exists():
                belt_data = _json.loads(belt_config_path.read_text(encoding='utf-8'))

                logger.info("ðŸŽ¯ äººç”Ÿã®é“æ¨™å°‚ç”¨ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°é–‹å§‹")

                # ã‚¹ãƒ†ãƒƒãƒ—1: å¸¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸Šæ›¸ããƒ»æœ€ä¸Šä½ã«ç§»å‹•
                logger.info("ðŸ“ å¸¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸Šæ›¸ããƒ»æœ€ä¸Šä½ã«ç§»å‹•...")
                move_and_update_belt_tracks_jinsei(belt_data, args.opening_offset, draft_dir, logger, title=args.title)

                # ã‚¹ãƒ†ãƒƒãƒ—2: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¨ãƒ³ãƒ‰ä½ç½®èª¿æ•´
                logger.info("âœ¨ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµ‚äº†ä½ç½®ã‚’èª¿æ•´...")
                total_duration_sec = belt_data.get('total_duration', 903.42)
                adjust_effect_duration(None, total_duration_sec, draft_dir, logger)

                # å†åº¦åŒæœŸï¼ˆãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°å¾Œï¼‰
                logger.info("ðŸ”„ ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°å¾Œã®åŒæœŸ...")
                if sync_draft_info_with_content(draft_dir):
                    logger.info("âœ… äººç”Ÿã®é“æ¨™ãƒ‰ãƒ©ãƒ•ãƒˆä½œæˆå®Œäº†")
                else:
                    logger.warning("âš ï¸  åŒæœŸå¤±æ•—")

            else:
                logger.warning(f"Belt config file not found: {belt_config_path}")
        except Exception as e:
            logger.error(f"Belt layer processing failed: {e}")
            import traceback
            logger.debug(traceback.format_exc())

    # --- Improve discoverability in output run dir ---
    try:
        import datetime, json as _json
        # Create a stable symlink from run_dir -> actual CapCut draft folder
        run_capcut_link = run_dir / 'capcut_draft'
        if run_capcut_link.exists() or run_capcut_link.is_symlink():
            try:
                if run_capcut_link.is_symlink() or run_capcut_link.is_file():
                    run_capcut_link.unlink()
                else:
                    import shutil
                    shutil.rmtree(run_capcut_link)
            except Exception:
                pass
        run_capcut_link.symlink_to(draft_dir)

        # Also drop an info JSON for quick reference/search in output/
        info = {
            'draft_name': args.new,
            'draft_path': str(draft_dir),
            'created_at': datetime.datetime.now().isoformat(timespec='seconds'),
            'template_used': template_name,
            'transform': {'tx': args.tx, 'ty': args.ty, 'scale': args.scale},
            'crossfade_sec': crossfade,
            'title': args.title,
            'srt_file': args.srt_file,
        }
        (run_dir / 'capcut_draft_info.json').write_text(_json.dumps(info, ensure_ascii=False, indent=2), encoding='utf-8')
    except Exception as e:
        print(f"Note: Could not create output symlink/info: {e}")


if __name__ == "__main__":
    main()
